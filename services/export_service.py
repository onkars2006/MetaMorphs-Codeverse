import os
from flask import abort, current_app, jsonify, send_file, url_for
import pdfkit
import qrcode
from docx import Document
from io import BytesIO
import markdown
import re
from docx.shared import Pt
from utils import WKHTMLTOPDF_PATH

def generate_pdf(plan):
    """Generate PDF document with proper formatting and error handling"""
    try:
        md = markdown.Markdown(extensions=['tables', 'attr_list'])
        
        def convert_content(content):
            html = md.convert(content)
            html = re.sub(r'<table>\s*<thead>\s*<tr>', 
                        '<table class="pdf-table"><thead><tr>', html)
            html = re.sub(r'<td>\s*(\|)?\s*', '<td>', html)
            html = re.sub(r'\s*(\|)?\s*</td>', '</td>', html)
            return html

        main_content = convert_content(plan['raw_markdown'])
        market_research = convert_content(plan['market_research'])
        tech_stack = convert_content(plan['tech_stack'])
        revenue_models = convert_content(plan['revenue_models'])

        pdf_styles = """
        <style>
            body {
                font-family: 'Helvetica', Arial, sans-serif;
                line-height: 1.6;
                color: #333;
                font-size: 12pt;
            }
            h1 { font-size: 24pt; margin: 20px 0 10px; }
            h2 { font-size: 18pt; margin: 15px 0 8px; }
            .pdf-table {
                width: 100%;
                border-collapse: collapse;
                margin: 15px 0;
                page-break-inside: avoid;
            }
            .pdf-table th {
                background-color: #667eea;
                color: white;
                padding: 12px;
                border: 1px solid #444;
                text-align: left;
            }
            .pdf-table td {
                padding: 10px;
                border: 1px solid #ddd;
                vertical-align: top;
            }
            .pdf-table tr:nth-child(even) {
                background-color: #f8f9fa;
            }
            .header-section {
                border-bottom: 2px solid #667eea;
                margin-bottom: 20px;
                padding-bottom: 10px;
            }
        </style>
        """

        full_html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>{plan['form_data']['startup_name']} Business Plan</title>
            {pdf_styles}
        </head>
        <body>
            <div class="header-section">
                <h1>{plan['form_data']['startup_name']}</h1>
                <p><strong>Industry:</strong> {plan['form_data']['industry']}</p>
                <p><strong>Business Model:</strong> {plan['form_data']['business_model']}</p>
            </div>
            
            {main_content}
            
            <h2>Market Research</h2>
            {market_research}
            
            <h2>Tech Stack</h2>
            {tech_stack}
            
            <h2>Revenue Models</h2>
            {revenue_models}
        </body>
        </html>
        """

        debug_html_path = os.path.join(current_app.config['UPLOAD_FOLDER'], 'debug.html')
        with open(debug_html_path, 'w', encoding='utf-8') as f:
            f.write(full_html)

        options = {
            'page-size': 'A4',
            'margin-top': '15mm',
            'margin-right': '10mm',
            'margin-bottom': '15mm',
            'margin-left': '10mm',
            'encoding': 'UTF-8',
            'quiet': '',
            'disable-smart-shrinking': '',
            'no-stop-slow-scripts': '',
            'enable-local-file-access': '',
            'dpi': 300,
            'header-right': '[page]/[topage]',
            'footer-center': 'Confidential - Generated by StartupIQ',
            'javascript-delay': '1000',
            'no-outline': None,
            'load-error-handling': 'ignore'
        }

        config = pdfkit.configuration(
            wkhtmltopdf=WKHTMLTOPDF_PATH,
            meta_tag_prefix='pdf-'
        )

        pdf = pdfkit.from_string(
            full_html,
            False,
            options=options,
            configuration=config
        )

        return send_file(
            BytesIO(pdf),
            mimetype='application/pdf',
            download_name=f"{plan['form_data']['startup_name'].replace(' ', '_')}_business_plan.pdf",
            as_attachment=True
        )

    except IOError as e:
        current_app.logger.error(f"File access error: {str(e)}")
        return jsonify({"error": "PDF generation failed: File system error"}), 500
    except Exception as e:
        current_app.logger.error(f"PDF generation error: {str(e)}\nHTML Content:\n{full_html}")
        return jsonify({
            "error": f"PDF generation failed: {str(e)}",
            "debug_html": f"/uploads/debug.html" if current_app.debug else None
        }), 500

def sanitize_html(content):
    """Remove editable attributes and JavaScript"""
    content = re.sub(r'\s?contenteditable="true"', '', content)
    content = re.sub(r'\s?oninput="autoSave\(\)"', '', content)
    return content

def generate_word_document(plan):
    """Convert all content to proper Word document"""
    doc = Document()
    style = doc.styles['Normal']
    font = style.font
    font.name = 'Calibri'
    font.size = Pt(11)

    process_markdown(doc, plan['raw_markdown'])
    
    doc.add_heading('üîç Market Research', level=1)
    process_markdown(doc, plan['market_research'])
    
    doc.add_heading('‚öôÔ∏è Tech Stack', level=1)
    process_markdown(doc, plan['tech_stack'])
    
    doc.add_heading('üí∞ Revenue Models', level=1)
    process_markdown(doc, plan['revenue_models'])

    buffer = BytesIO()
    doc.save(buffer)
    buffer.seek(0)
    return send_file(
        buffer,
        mimetype='application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        download_name='business_plan.docx'
    )

def process_markdown(doc, content):
    """Improved markdown processor for Word documents"""
    in_table = False
    table = None
    list_level = 0

    for line in content.split('\n'):
        line = line.strip()
        
        if line.startswith('#'):
            level = min(line.count('#'), 6)
            text = line.replace('#', '').strip()
            doc.add_heading(text, level=level-1)
            continue
            
        if re.match(r'^[\-\*\+] ', line):
            p = doc.add_paragraph(style='ListBullet')
            p.add_run(line[2:].strip())
            continue
            
        if '|' in line:
            cols = [c.strip() for c in line.split('|') if c.strip()]
            if not in_table:
                table = doc.add_table(rows=1, cols=len(cols))
                table.style = 'Table Grid'
                hdr_cells = table.rows[0].cells
                for i, col in enumerate(cols):
                    hdr_cells[i].text = col
                in_table = True
            else:
                row_cells = table.add_row().cells
                for i, col in enumerate(cols):
                    row_cells[i].text = col
            continue
        else:
            in_table = False
            
        if line:
            doc.add_paragraph(line)
            
        list_stack = []


def generate_full_markdown(plan):
    """Combine all sections into final markdown"""
    return f"""
{plan['raw_markdown']}

## üîç Market Research
{plan['market_research']}

## ‚öôÔ∏è Tech Stack
{plan['tech_stack']}

## üí∞ Revenue Models
{plan['revenue_models']}
    """
def generate_qr_code(plan_id, plan):
    try:
        # Handle both dictionary and ORM object
        if hasattr(plan, 'view_key'):
            view_key = plan.view_key
        elif isinstance(plan, dict) and 'view_key' in plan:
            view_key = plan['view_key']
        else:
            raise ValueError("Plan object doesn't have view_key property")
            
        view_url = url_for('plans.view_plan', plan_id=plan_id, view_key=view_key, _external=True)
        qr = qrcode.make(view_url)
        buffer = BytesIO()
        qr.save(buffer, format='PNG')
        buffer.seek(0)
        return send_file(buffer, mimetype='image/png', download_name='plan_qr.png', as_attachment=False)
    except Exception as e:
        current_app.logger.error(f"QR generation failed: {str(e)}")
        return jsonify({"error": "Failed to generate QR code"}), 500
